/* uniq: remove duplicate reads from a file of mapped reads in the
 * dnmtools format (as output from format_reads), based on identical
 * mapping location and alignment to the reference.
 *
 * Copyright (C) 2013-2023 University of Southern California and
 *                         Andrew D. Smith
 *
 * Author: Andrew D. Smith
 *
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 */

#include <cstdint> // for [u]int[0-9]+_t
#include <iostream>
#include <random>
#include <stdexcept>
#include <string>
#include <vector>

// generated by autotools
#include <config.h>

// from HTSlib
#include <htslib/sam.h>
#include <htslib/thread_pool.h>

// from smithlab
#include "GenomicRegion.hpp"
#include "OptionParser.hpp"
#include "bsutils.hpp"
#include "smithlab_os.hpp"
#include "smithlab_utils.hpp"

#include "dnmt_error.hpp"

using std::cerr;
using std::endl;
using std::ifstream;
using std::ofstream;
using std::runtime_error;
using std::string;
using std::to_string;
using std::vector;

namespace uniq_random {
  // ADS: I made this namespace and functions because different
  // implementations of rand() on different OS meant that even with
  // the same seed, the results could be different. This meant testing
  // didn't work.
  // ADS: (TODO) refactor this
  bool initialized = false;
  std::default_random_engine e;
  std::uniform_int_distribution<int> di;

  void
  initialize(const size_t the_seed) {
    e = std::default_random_engine(the_seed);
    initialized = true;
  }

  int
  rand() {
    // ADS: should have same range as ordinary rand() by properties of
    // std::uniform_int_distribution default constructor.
    // assert(initialized);
    return di(e);
  }
} // namespace uniq_random

inline bool
format_is_bam_or_sam(htsFile *hts) {
  const htsFormat *fmt = hts_get_format(hts);
  return fmt->category == sequence_data &&
         (fmt->format == bam || fmt->format == sam);
}

inline string
qname(const bam1_t *b) {
  return string(bam_get_qname(b));
}

inline int32_t
get_tid(bam1_t *b) {
  return b->core.tid;
}

inline size_t
qlen(const bam1_t *r) {
  return bam_cigar2qlen(r->core.n_cigar, bam_get_cigar(r));
}

inline bool
precedes_by_start(const bam1_t *a, const bam1_t *b) {
  return a->core.tid == b->core.tid && a->core.pos < b->core.pos;
}

inline bool
precedes_by_end_and_strand(const bam1_t *a, const bam1_t *b) {
  const size_t end_a = bam_endpos(a), end_b = bam_endpos(b);
  return (end_a < end_b || (end_a == end_b && bam_is_rev(a) < bam_is_rev(b)));
}

inline bool
equivalent_chrom_and_start(const bam1_t *a, const bam1_t *b) {
  return a->core.pos == b->core.pos && a->core.tid == b->core.tid;
}

inline bool
equivalent_end_and_strand(const bam1_t *a, const bam1_t *b) {
  return bam_endpos(a) == bam_endpos(b) && bam_is_rev(a) == bam_is_rev(b);
}

struct rd_stats { // keep track of good bases/reads in and out
  size_t bases;
  size_t reads;

  rd_stats(): bases(0), reads(0) {}

  void
  update(bam1_t *b) {
    bases += qlen(b);
    ++reads;
  }
};

static void
write_stats_output(const rd_stats &rs_in, const rd_stats &rs_out,
                   const size_t reads_duped, const string &statfile) {
  if (!statfile.empty()) {
    const size_t reads_removed = rs_in.reads - rs_out.reads;
    const double non_dup_frac =
        (rs_out.reads - reads_duped) / static_cast<double>(rs_in.reads);
    const double dup_rate =
        (reads_removed + reads_duped) / static_cast<double>(reads_duped);
    ofstream out_stat(statfile);
    if (!out_stat) throw runtime_error("bad stats output file");
    out_stat << "total_reads: " << rs_in.reads << endl
             << "total_bases: " << rs_in.bases << endl
             << "unique_reads: " << rs_out.reads << endl
             << "unique_read_bases: " << rs_out.bases << endl
             << "non_duplicate_fraction: " << non_dup_frac << endl
             << "duplicate_reads: " << reads_duped << endl
             << "reads_removed: " << reads_removed << endl
             << "duplication_rate: " << dup_rate << endl;
  }
}

static void
write_hist_output(const vector<size_t> &hist, const string &histfile) {
  if (!histfile.empty()) {
    ofstream out_hist(histfile);
    if (!out_hist) throw runtime_error("bad hist output file");
    for (size_t i = 0; i < hist.size(); ++i)
      if (hist[i] > 0) out_hist << i << '\t' << hist[i] << '\n';
  }
}

/* The "inner" buffer corresponds to all reads sharing chrom, start,
 * end and strand, and is a contiguous subset of the "outer" buffer
 * that shares the same end and strand.
 */
static void
process_inner_buffer(const vector<bam1_t *>::const_iterator it,
                     const vector<bam1_t *>::const_iterator jt, sam_hdr_t *hdr,
                     samFile *out, rd_stats &rs_out, size_t &reads_duped,
                     vector<size_t> &hist) {
  const size_t n_reads = std::distance(it, jt);
  const size_t selected = uniq_random::rand() % n_reads;
  if (sam_write1(out, hdr, *(it + selected)) < 0)
    throw runtime_error("failed writing bam record");
  if (hist.size() <= n_reads) hist.resize(n_reads + 1);
  hist[n_reads]++;
  rs_out.update(*(it + selected));
  reads_duped += (n_reads > 1);
}

/* The buffer corresponds to reads sharing the same mapping chromosome
   and start position. These are gathered and then processed together. */
static void
process_buffer(rd_stats &rs_out, size_t &reads_duped, vector<size_t> &hist,
               vector<bam1_t *> &buffer, sam_hdr_t *hdr, samFile *out) {
  sort(begin(buffer), end(buffer), precedes_by_end_and_strand);
  auto it(begin(buffer));
  auto jt = it + 1;
  for (; jt != end(buffer); ++jt)
    if (!equivalent_end_and_strand(*it, *jt)) {
      process_inner_buffer(it, jt, hdr, out, rs_out, reads_duped, hist);
      it = jt;
    }
  process_inner_buffer(it, jt, hdr, out, rs_out, reads_duped, hist);

  // free the bam1_t pointers before clearing the buffer
  for (size_t i = 0; i < buffer.size(); ++i)
    if (buffer[i] != 0) {
      bam_destroy1(buffer[i]);
      buffer[i] = 0;
    }
  buffer.clear();
}

static bam1_t *
get_read(samFile *hts, sam_hdr_t *hdr) {
  bam1_t *b = bam_init1();
  const int result = sam_read1(hts, hdr, b);
  if (result >= 0) return b;

  if (result < -1)
    throw runtime_error("error reading file: " + string(hts->fn));
  else // -1 should mean EOF, so we free this read
    bam_destroy1(b);
  return 0;
}

static void
uniq(const bool VERBOSE, const size_t n_threads, const string &cmd,
     const string &infile, const string &statfile, const string &histfile,
     const bool bam_format, const string &outfile) {
  // ADS: (below) At some point the errno here is set to 3=ESRCH ("No
  // such process"?) when using HTSlib 1.17 on macos ventura
  int prev_errno = errno;
  samFile *hts = hts_open(infile.c_str(), "r");
  if (!hts || errno != prev_errno) throw dnmt_error("error opening: " + infile);

  htsThreadPool the_thread_pool{hts_tpool_init(n_threads), 0};
  if (hts_set_thread_pool(hts, &the_thread_pool) < 0)
    throw runtime_error("error setting threads");

  if (!format_is_bam_or_sam(hts))
    throw runtime_error("bad file format: " + infile);

  sam_hdr_t *hdr = sam_hdr_read(hts);
  if (!hdr) throw runtime_error("failed to read header: " + infile);

  // open the output file
  samFile *out = hts_open(outfile.c_str(), bam_format ? "wb" : "w");

  if (hts_set_thread_pool(out, &the_thread_pool) < 0)
    throw runtime_error("error setting threads");

  // take care of the output file's header
  sam_hdr_t *hdr_out = bam_hdr_dup(hdr);
  if (sam_hdr_add_line(hdr_out, "PG", "ID", "DNMTOOLS", "VN", VERSION, "CL",
                       cmd.c_str(), NULL))
    throw runtime_error("failed to format header");
  if (sam_hdr_write(out, hdr_out))
    throw runtime_error("failed to output header");
  bam_hdr_destroy(hdr_out);

  // values to tabulate stats; no real cost
  rd_stats rs_in, rs_out;
  size_t reads_duped = 0;
  vector<size_t> hist;

  // try to load the first read
  prev_errno = errno;
  bam1_t *aln = get_read(hts, hdr);
  if (errno != prev_errno)
    throw runtime_error("failed parsing read from input file");

  if (aln) { // data file is not empty

    rs_in.update(aln); // update for the input we just got

    vector<bam1_t *> buffer(1, aln); // select output from this buffer

    // to check that reads are sorted properly
    vector<bool> chroms_seen(hdr->n_targets, false);
    int32_t cur_chrom = get_tid(aln);

    while ((aln = get_read(hts, hdr))) {
      rs_in.update(aln);

      // below works because buffer reset at every new chrom
      if (precedes_by_start(aln, buffer[0]))
        throw runtime_error("not sorted: " + qname(buffer[0]) + " " +
                            qname(aln));

      const int32_t chrom = get_tid(aln);
      if (chrom != cur_chrom) {
        if (chroms_seen[chrom]) throw runtime_error("input not sorted");
        chroms_seen[chrom] = true;
        cur_chrom = chrom;
      }

      if (!equivalent_chrom_and_start(buffer[0], aln))
        process_buffer(rs_out, reads_duped, hist, buffer, hdr, out);
      buffer.push_back(aln);
    }
    process_buffer(rs_out, reads_duped, hist, buffer, hdr, out);
  }

  // remember to turn off the lights
  bam_hdr_destroy(hdr);
  hts_close(out);
  hts_close(hts);
  hts_tpool_destroy(the_thread_pool.pool);

  // write any additional output requested
  write_stats_output(rs_in, rs_out, reads_duped, statfile);
  write_hist_output(hist, histfile);
}

int
main_uniq(int argc, const char **argv) {
  try {
    bool VERBOSE = false;

    bool bam_format = false;
    bool use_stdout = false;

    // ADS: Not recommended to change this seed. It shouldn't matter
    // at all, and we want results to behave as deterministic.
    size_t the_seed = 408;
    string outfile;
    string statfile;
    string histfile;
    size_t n_threads = 1;

    /****************** COMMAND LINE OPTIONS ********************/
    OptionParser opt_parse(strip_path(argv[0]),
                           "program to remove "
                           "duplicate reads from sorted mapped reads",
                           "<in-file> [out-file]", 2);
    opt_parse.add_opt("threads", 't', "number of threads", false, n_threads);
    opt_parse.add_opt("stats", 'S', "statistics output file", false, statfile);
    opt_parse.add_opt("hist", '\0',
                      "histogram output file for library"
                      " complexity analysis",
                      false, histfile);
    opt_parse.add_opt("bam", 'B', "output in BAM format", false, bam_format);
    opt_parse.add_opt("stdout", '\0', "write to standard output", false,
                      use_stdout);
    opt_parse.add_opt("seed", 's', "random seed", false, the_seed);
    opt_parse.add_opt("verbose", 'v', "print more run info", false, VERBOSE);
    opt_parse.set_show_defaults();
    vector<string> leftover_args;
    opt_parse.parse(argc, argv, leftover_args);
    if (opt_parse.about_requested() || opt_parse.help_requested() ||
        leftover_args.empty()) {
      cerr << opt_parse.help_message() << endl
           << opt_parse.about_message() << endl;
      return EXIT_SUCCESS;
    }
    if (opt_parse.option_missing()) {
      cerr << opt_parse.option_missing_message() << endl;
      return EXIT_SUCCESS;
    }
    if ((leftover_args.size() == 1 && !use_stdout) ||
        (leftover_args.size() == 2 && use_stdout)) {
      cerr << opt_parse.help_message() << endl
           << opt_parse.about_message() << endl;
      return EXIT_SUCCESS;
    }
    const string infile(leftover_args.front());
    if (leftover_args.size() == 2 && !use_stdout)
      outfile = leftover_args.back();
    else
      outfile = string("-"); // so htslib can write to stdout
    /****************** END COMMAND LINE OPTIONS *****************/

    // ADS: Random here is because we choose randomly when keeping one
    // among duplicate reads.
    uniq_random::initialize(the_seed);

    std::ostringstream cmd;
    copy(argv, argv + argc, std::ostream_iterator<const char *>(cmd, " "));

    if (VERBOSE)
      cerr << "[output file: " << outfile << "]" << endl
           << "[output format: " << (bam_format ? "B" : "S") << "AM]" << endl
           << "[threads requested: " << n_threads << "]" << endl
           << "[command line: \"" << cmd.str() << "\"]" << endl
           << "[random number seed: " << the_seed << "]" << endl;

    uniq(VERBOSE, n_threads, cmd.str(), infile, statfile, histfile, bam_format,
         outfile);
  }
  catch (const runtime_error &e) {
    cerr << e.what() << endl;
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
